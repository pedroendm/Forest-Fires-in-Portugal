---
title: "Forest Fires in Portugal"
author:
  - "Pedro Mota"
  - "Tatiana Araújo"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

```{r, echo=FALSE}
library(readr)
library(tibble)
library(dplyr)
```

# Data importation, clean-up and pre-processing

```{r, include=FALSE}
setwd('/home/pedromota/dm1/Forest-Fires-in-Portugal/')
```

## Data Importation
Read the .csv file, containing the training data, as a tibble.
``` {r}
ds <- as_tibble(read_csv("fires_train.csv", na = c("-", "NA")))
```

Drop column "alert_source", because it's all missing values. We may, also, drop the column "village_veget_area", and the columns "region", "district", "municipality" and "parish", because they are redundant. In the case of the attribute "village_veget_area", it is redundant because it's simply the sum of the attributes "village_area" and "veget_area" and, in the case of the attributes "region", "district", "municipality" and "parish", it's because we already have the coordinates in the attributes "lat" and "lon", which defines precisely the location of the fire. 

```{r, echo=FALSE}
ds <- select(ds, -alert_source, -village_veget_area, -(region:parish))
```

COORDENADAS
Regarding the latitude and longitude coordinates, they are 2 features that represent a three dimensional space, which means that the longitude coordinate goes all around, which presents a problem, because the two most extreme values are actually very close together. In order to solve this problem, we converted the coordinates into to a x, y, and z coordinate space. In this space, close points are also close in reality. # EXPLICAR QUE AFINAL N É PROBLEMA, VISTO SER SÓ PORTUGAL, PORTANTO SÓ PASSAMOS A DECIMAL
Font: https://datascience.stackexchange.com/questions/13567/ways-to-deal-with-longitude-latitude-feature

```{r}
coordinates_to_decimal <- function(ds) {
  n = dim(ds)[1] # Number of rows in the dataset 
  num = "(([0-9]+\\.[0-9]+)|([0-9]+))" # Regexp for integer and real numbers
  
  # Extract the numbers from the strings
  # lat column, becomes lat_degree, lat_minutes, lat_seconds
  # lon column, becomes lon_degree, lon_minutes, lon_seconds
  parsed_lat <- str_extract_all(ds$lat, num, simplify=TRUE)
  parsed_lon <- str_extract_all(ds$lon, num, simplify=TRUE)
  
  lat_degree = parsed_lat[1:n]
  lat_minutes = parsed_lat[(n+1):(2*n)]
  lat_seconds = parsed_lat[(2*n+1):(3*n)] 
  lon_degree = parsed_lon[1:n]
  lon_minutes = parsed_lon[(n+1):(2*n)]
  lon_seconds = parsed_lon[(2*n+1):(3*n)]
  
  # Convert the coordinates to a decimal representation
  ds <- mutate(ds, lat=as.double(lat_degree) + as.double(lat_minutes)/60 + as.double(lat_seconds)/3600,
                   lon=as.double(lon_degree) + as.double(lon_minutes)/60 + as.double(lon_seconds)/3600)
  return(ds)
}
```

```{r}
ds <- coordinates_to_decimal(ds)
```

Paste X_hour in X_date.
```{r}
ds$alert_date = as.POSIXct(paste(format(ds$alert_date, format="%Y-%m-%d"), ds$alert_hour), tz='UTC')
ds$extinction_date = as.POSIXct(paste(format(ds$extinction_date, format="%Y-%m-%d"), ds$extinction_hour), tz='UTC')
ds$firstInterv_date = as.POSIXct(paste(format(ds$firstInterv_date, format="%Y-%m-%d"), ds$firstInterv_hour), tz='UTC')
ds <- select(-alert_hour, -extinction_hour, -firstInterv_hour)
```

# Data exploratory analysis

# Predictive modelling 
